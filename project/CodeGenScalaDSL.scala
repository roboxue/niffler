import java.io.PrintWriter

import sbt.{File, taskKey}

import scala.collection.immutable

/**
  * Automatically generate some code during "sbt compile"
  *
  * @author robert xue
  * @since 12/26/17.
  */
object CodeGenScalaDSL {
  val FORMULA = "Formula"
  val DATA_FLOW = "DataFlow"
  val DATA_SOURCE = "DataSource"
  val TOKEN = "Token"
  val REQUIREMENT = "Requirement"

  def genericParam(prefix: String, count: Int): immutable.Seq[String] = (1 to  count).map(c => s"$prefix$c")

  def params(namePrefix: String, typePrefix: String, wrapper: Option[String], count: Int): immutable.Seq[String] = {
    (1 to  count).map(c => {
      wrapper match {
        case Some(w) =>
          s"$namePrefix$c: $w[$typePrefix$c]"
        case None =>
          s"$namePrefix$c: $typePrefix$c"
      }
    })
  }

  def generateFormulaCode(depCount: Int): String = {
    require(depCount > 0)
    val p = params("t", "T", Some(TOKEN), depCount).mkString(",")
    val T = genericParam("T", depCount).mkString(",")
    val tokens = genericParam("t", depCount).mkString(",")
    val stateApply = (1 to  depCount).map(c => s"state(t$c)").mkString(",")

    s"""case class $FORMULA$depCount[$T, R]($p, outlet: $TOKEN[R]) extends $FORMULA[R] {
       |  override val dependsOn: Seq[$TOKEN[_]] = Seq($tokens)
       |
       |  def :=(impl: ($T) => R): $DATA_FLOW[R] = implBy(impl)
       |
       |  def :=>(futureImpl: ($T) => Future[R]): $DATA_FLOW[R] = implByFuture(futureImpl)
       |
       |  def implBy(impl: ($T) => R): $DATA_FLOW[R] =
       |    new Sync$DATA_FLOW[R](dependsOn, outlet, state => impl($stateApply))
       |
       |  def implByFuture(futureImpl: ($T) => Future[R]): Async$DATA_FLOW[R] =
       |    new Async$DATA_FLOW[R](dependsOn, outlet, state => futureImpl($stateApply))
       |}
     """.stripMargin
  }

  def generateRequirement(depCount: Int): String = {
    val p = params("t", "T", Some(TOKEN), depCount).mkString(",")
    val T = genericParam("T", depCount).mkString(",")
    val tokens = genericParam("t", depCount).mkString(",")
    val stateApply = (1 to  depCount).map(c => s"state(t$c)").mkString(",")
    require(depCount > 0)
    s"""case class $REQUIREMENT$depCount[$T]($p) extends $REQUIREMENT {
       |  override val dependsOn: Seq[$TOKEN[_]] = Seq($tokens)
       |
       |  def ~>[Out](outlet: $TOKEN[Out]): $FORMULA$depCount[$T, Out] = outputTo(outlet)
       |
       |  def outputTo[Out](outlet: $TOKEN[Out]): $FORMULA$depCount[$T, Out] = $FORMULA$depCount($tokens, outlet)
       |
       |  def :=[R](impl: ($T) => R): $DATA_SOURCE[R] = implBy(impl)
       |
       |  def :=>[R](futureImpl: ($T) => Future[R]): $DATA_SOURCE[R] = implByFuture(futureImpl)
       |
       |  def implBy[R](impl: ($T) => R): $DATA_SOURCE[R] =
       |    new Sync$DATA_SOURCE[R](dependsOn, state => impl($stateApply))
       |
       |  def implByFuture[R](futureImpl: ($T) => Future[R]): Async$DATA_SOURCE[R] =
       |    new Async$DATA_SOURCE[R](dependsOn, state => futureImpl($stateApply))
       |}
     """.stripMargin
  }

  def generateRequires(depCount: Int): String = {
    def applyFunctions: String = (1 to depCount).map(i => {
      val p = params("t", "T", Some(TOKEN), i).mkString(",")
      val T = genericParam("T", i).mkString(",")
      val tokens = genericParam("t", i).mkString(",")
      s"  def apply[$T]($p): $REQUIREMENT$i[$T] = $REQUIREMENT$i($tokens)"
    }).mkString(System.lineSeparator())

    s"""object Requires {
       |$applyFunctions
       |}
     """.stripMargin
  }

  final val generateScalaCode = taskKey[Seq[File]]("Generate boilerplate scala code for niffler core.")

  def saveToFile(srcFolder: File): File = {
    srcFolder.mkdirs()
    val file = new File(srcFolder, "com/roboxue/niffler/AutoGeneratedSyntax.scala")
    file.getParentFile.mkdirs()
    val writer = new PrintWriter(file)
    try {
      // Function types with 23 arity aren't supported by scala
      writer.println("// auto generated by sbt compile")
      writer.println("package com.roboxue.niffler")
      writer.println("import scala.concurrent.Future")
      writer.println()
      val maxArity = 20
      (1 to maxArity).foreach(i => {
        writer.println(generateFormulaCode(i))
        writer.println(generateRequirement(i))
      })
      writer.println(generateRequires(maxArity))
      file
    } finally {
      writer.close()
    }
  }
}
