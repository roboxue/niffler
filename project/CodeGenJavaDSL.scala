import java.io.PrintWriter

import sbt.{File, taskKey}

import scala.collection.immutable
import scala.collection.mutable.ListBuffer

/**
  * Automatically generate some code during "sbt compile"
  *
  * @author robert xue
  * @since 12/26/17.
  */
object CodeGenJavaDSL {
  val FORMULA = "Formula"
  val TOKEN = "Token"

  def generateFunctionInterface(depCount: Int): String = {
    val tokensValueParamsWithType = (1 to  depCount).map(i => s"T$i t$i").mkString(",")
    val tokenTypeParam = (1 to  depCount).map(i => s"T$i").mkString(",")
    s"""@FunctionalInterface
       |public interface Implementation$depCount<$tokenTypeParam, Result> {
       |    Result apply($tokensValueParamsWithType) throws Exception;
       |}
       |
     """.stripMargin
  }
  
  def generateFormulaCode(depCount: Int): String = {
    require(depCount > 0)
    val className = s"$FORMULA$depCount"
    val tokensParamsWithType = (1 to  depCount).map(i => s"$TOKEN<T$i> t$i").mkString(",")
    val tokenCommaList = (1 to  depCount).map(i => s"t$i").mkString(",")
    val tokenTypeParam = (1 to  depCount).map(i => s"T$i").mkString(",")
    val tokenDefs = (1 to  depCount).map(i => s"    private final $TOKEN<T$i> t$i;").mkString(System.lineSeparator())
    val tokenAssignments = (1 to  depCount).map(i => s"        this.t$i = t$i;").mkString(System.lineSeparator())
    val fetchFromState = (1 to  depCount).map(c => s"state.apply(t$c)").mkString(",")
    val funcClassName = s"Implementation$depCount"

    s"""// auto generated by sbt compile
       |package com.roboxue.niffler.javaDSL;
       |
       |import com.google.common.collect.ImmutableList;
       |import com.roboxue.niffler.LanguageBridge;
       |import com.roboxue.niffler.SyncDataFlow;
       |import com.roboxue.niffler.Token;
       |
       |public class $className<$tokenTypeParam, R> implements $FORMULA<R> {
       |    private final ImmutableList<Token<?>> dependsOn;
       |    private final $TOKEN<R> outlet;
       |$tokenDefs
       |    public $className($tokensParamsWithType, $TOKEN<R> outlet) {
       |        this.dependsOn = ImmutableList.of($tokenCommaList);
       |        this.outlet = outlet;
       |$tokenAssignments
       |    }
       |
       |    @Override
       |    public ImmutableList<Token<?>> getDependsOn() {
       |        return dependsOn;
       |    }
       |
       |    @Override
       |    public $TOKEN<R> getOutlet() {
       |        return outlet;
       |    }
       |
       |    public SyncDataFlow<R> implBy($funcClassName<$tokenTypeParam, R> impl) {
       |        return new SyncDataFlow<>(LanguageBridge.javaIterableAsSeq(dependsOn), outlet, (state) -> {
       |            try {
       |                return impl.apply($fetchFromState);
       |            } catch (Exception e) {
       |                throw new RuntimeException(e);
       |            }
       |        });
       |    }
       |}
     """.stripMargin
  }

  final val generateJavaCode = taskKey[Seq[File]]("Generate boilerplate java code for niffler core.")

  def saveToFile(srcFolder: File): Seq[File] = {
    srcFolder.mkdirs()
    val parent = new File(srcFolder, "com/roboxue/niffler/javaDSL")
    parent.mkdirs()
    val maxArity = 20
    val files = ListBuffer.empty[File]
    (1 to maxArity).foreach(i => {
      val file = new File(parent, s"Formula$i.java")
      val writer = new PrintWriter(file)
      try {
        writer.println(generateFormulaCode(i))
      } finally {
        writer.close()
      }
      files += file
    })
    (1 to maxArity).foreach(i => {
      val file = new File(parent, s"Implementation$i.java")
      val writer = new PrintWriter(file)
      try {
        writer.println("// auto generated by sbt compile")
        writer.println("package com.roboxue.niffler.javaDSL;")
        writer.println()
        writer.println(generateFunctionInterface(i))
      } finally {
        writer.close()
      }
      files += file
    })
    files
  }
}
