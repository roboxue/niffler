package com.roboxue.niffler

import scala.concurrent.Future

/**
  * @author robert.xue
  * @since 7/15/18
  */
trait Formula[T] {
  val dependsOn: Seq[TokenMeta]
  val outlet: Token[T]
}

case class Formula0[R](outlet: Token[R]) extends Formula[R] {
  override val dependsOn: Seq[Token[_]] = Seq.empty

  def :=(impl: => R): DataFlow[R] = implBy(impl)

  def implBy(impl: => R): DataFlow[R] = new SyncDataFlow[R](dependsOn, outlet, _ => impl)

  def :=>(futureImpl: => Future[R]): AsyncDataFlow[R] = implByFuture(futureImpl)

  def implByFuture(futureImpl: => Future[R]): AsyncDataFlow[R] =
    new AsyncDataFlow[R](dependsOn, outlet, _ => futureImpl)
}

// The other stuff will be auto generated by sbt

case class WildcardFormula[R, Z](dependencies: Seq[Token[Z]], outlet: Token[R]) extends Formula[R] {
  override val dependsOn: Seq[Token[_]] = dependencies

  def :=(impl: Seq[Z] => R): DataFlow[R] = implBy(impl)

  def implBy(impl: Seq[Z] => R): DataFlow[R] =
    new SyncDataFlow[R](dependsOn, outlet, state => {
      impl(dependencies.map(state.apply))
    })

  def :=>(futureImpl: Seq[Z] => Future[R]): AsyncDataFlow[R] = implByFuture(futureImpl)

  def implByFuture(futureImpl: Seq[Z] => Future[R]): AsyncDataFlow[R] =
    new AsyncDataFlow[R](dependsOn, outlet, state => {
      futureImpl(dependencies.map(state.apply))
    })
}
